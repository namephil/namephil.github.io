<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="Phil">
  <link 
    rel="icon" 
    href="/../hexo-theme-Kaze/source/image/logo.png">
  <title>Vue</title>
  
    
      <meta 
        property="og:title" 
        content="Vue">
    
    
      <meta 
        property="og:url" 
        content="http://example.com/2022/07/10/Vue/index.html">
    
    
      <meta 
        property="og:img" 
        content="https://th.bing.com/th/id/OIP._zjEZ4RTuXe2xbBMbJOzqwHaHa?w=169&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7">
    
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2022-07-10">
      <meta 
        property="og:article:modified_time" 
        content="2022-08-03">
      <meta 
        property="og:article:author" 
        content="Nana">
      
        
          <meta 
            property="og:article:tag" 
            content="面试题">
        
      
    
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  <link rel="preload" href="/css/main.css" as="style" >
  
  <link rel="modulepreload" href="//instant.page/5.1.0">
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
  
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
      }
    };
    setDarkmode();
    </script>
  
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <a class="navbar-logo-main" href="/">
      
        <img 
          class="navbar-logo-img"
          width="32"
          height="32"
          src="/../hexo-theme-Kaze/source/image/logo.png" 
          alt="blog logo">
      
      <span class="navbar-logo-dsc">Phil</span>
      </a>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          Home
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          Archive
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          Tags
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          Categories
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          About
        
      </a>
    
      <a 
        href="/links" 
        class="navbar-menu-item">
        
          Friends
        
      </a>
    
    <button 
      class="navbar-menu-item darknavbar navbar-menu-btn" 
      aria-label="Toggle dark mode"
      id="dark">
      <i class="iconfont icon-weather"></i>
    </button>
    <button 
      class="navbar-menu-item searchnavbar navbar-menu-btn" 
      aria-label="Toggle search"
      id="search">
      <!-- <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i> -->
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img"
        class="iconify iconify--ion" width="28" height="28" preserveAspectRatio="xMidYMid meet" viewBox="0 0 512 512">
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M256 80a176 176 0 1 0 176 176A176 176 0 0 0 256 80Z"></path>
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M232 160a72 72 0 1 0 72 72a72 72 0 0 0-72-72Z"></path>
        <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="28"
          d="M283.64 283.64L336 336"></path>
      </svg>
    </button>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="https://th.bing.com/th/id/OIP._zjEZ4RTuXe2xbBMbJOzqwHaHa?w=169&h=180&c=7&r=0&o=5&pid=1.7" 
    class="author-img"
    width="88"
    height="88"
    alt="author avatar">

<p class="author-name">Nana</p>
<p class="author-description">a coder/"painter"</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>9</span>
    <span>Posts</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>4</span>
    <span>Categories</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>2</span>
    <span>Tags</span>
  </a>
</div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9-%EF%BC%9F"><span class="toc-text">1、谈谈你对 SPA 单页面模式的理解，优缺点 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMVVM"><span class="toc-text">2、什么是MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%B0%88%E8%B0%88%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-text">3、谈谈双向绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4、生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86"><span class="toc-text">5、Vue响应式数据原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Proxy%E4%B8%8EObject-defineProperty%E7%9A%84%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="toc-text">6、Proxy与Object.defineProperty的优劣对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81v-show%E5%92%8Cv-if%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7、v-show和v-if的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81v-if-%E5%92%8Cv-for%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%B8%80%E8%B5%B7%E7%94%A8"><span class="toc-text">8、v-if 和v-for为什么不建议一起用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81vue%E4%B8%ADdata%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-text">9、vue中data为什么必须是函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81nextTick"><span class="toc-text">10、nextTick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81key"><span class="toc-text">11、key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81v-model-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-text">12、v-model 双向数据绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81router%E5%92%8Croute%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13、router和route的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81Vuex-%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-%EF%BC%9F"><span class="toc-text">14、Vuex 页面刷新数据丢失怎么解决 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E4%BD%A0%E9%83%BD%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B-Vue-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%E8%BF%98%E6%9C%89%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E5%81%9A-%EF%BC%9F"><span class="toc-text">15、你都做过哪些 Vue 的性能优化，还有有哪些可以做 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81Vue%E6%9C%89%E4%BA%86%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%8C%E4%B8%BA%E4%BD%95%E8%BF%98%E8%A6%81Diff"><span class="toc-text">16、Vue有了数据响应式，为何还要Diff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84"><span class="toc-text">17、vue如何监听数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88vue%E8%A6%81%E9%87%87%E7%94%A8%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0"><span class="toc-text">18、为什么vue要采用异步更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81computed%E3%80%81watch%E3%80%81method%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">19、computed、watch、method的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81vue-router%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-text">20、vue-router的模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">21、组件间的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81vue-router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D"><span class="toc-text">22、vue-router有哪几种钩子函数(导航守卫有多少种)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-Router%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-text">vue-Router路由钩子解析流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">23、事件修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81v-html%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">24、v-html会导致什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E6%80%8E%E4%B9%88%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6"><span class="toc-text">25、怎么缓存组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFrender%E5%87%BD%E6%95%B0"><span class="toc-text">26、什么是render函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81documentFragment%E5%92%8C%E4%B8%80%E6%AC%A1%E6%80%A7%E6%B8%B2%E6%9F%93%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-text">27、documentFragment和一次性渲染有什么不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">28、自定义指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81Vue%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0"><span class="toc-text">29、Vue获取DOM元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E9%97%AA%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-text">30、初始化页面闪动问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-text">31、数组扁平化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-emit%E5%90%8E%E9%9D%A2%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">32.$emit后面的两个参数是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%8F%92%E6%A7%BD"><span class="toc-text">33.插槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81mixin"><span class="toc-text">34、mixin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E6%8F%8F%E8%BF%B0vue%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E2%80%93%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E2%80%93%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2UI%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">35、描述vue从初始化页面–修改数据–刷新页面UI的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81class-%E4%B8%8E-style-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%9F"><span class="toc-text">36、class 与 style 如何动态绑定？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95"><span class="toc-text">37、vue中的diff算法</span></a></li></ol></li></ol>
      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>Categories
  </div>
  <div class="categories-list">
    
      <a href="/categories/%E5%89%8D%E7%AB%AF%EF%BC%8C%E7%AE%97%E6%B3%95/">
        <div class="categories-list-item">
          前端，算法
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/%E5%89%8D%E7%AB%AF-HTML-CSS/">
        <div class="categories-list-item">
          前端-HTML-CSS
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/%E5%89%8D%E7%AB%AF-javascript/">
        <div class="categories-list-item">
          前端-javascript
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/%E5%89%8D%E7%AB%AF-Vue/">
        <div class="categories-list-item">
          前端-Vue
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>hot tags
  </div>
  <div class="tags-list">
    
      <a 
        href="/tags/%E5%89%8D%E7%AB%AF/" 
        title="前端">
        <div class="tags-list-item">前端</div>
      </a>
    
      <a 
        href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" 
        title="面试题">
        <div class="tags-list-item">面试题</div>
      </a>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <main class="main-column">
              
<article class="card card-content">
  <header>
    <h1 class="post-title">
      Vue
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2022-07-10T10:16:24.000Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2022-07-10</span>
    </time>
    
      <span class="dot"></span>
      
        <a 
          href="/categories/%E5%89%8D%E7%AB%AF-Vue/" 
          class="post-meta-link">
          -[前端,Vue]
        </a>
      
    
    
      <span class="dot"></span>
      <span>5.9k words</span>
    
  </div>
  
    <div 
      class="post-meta post-show-meta" 
      style="margin-top: -10px;">
      <div style="display: flex; align-items: center;">
        <i 
          class="iconfont icon-biaoqian" 
          style="margin-right: 2px; font-size: 1.15rem;">
        </i>
        
          
          <a 
            href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" 
            class="post-meta-link">
            面试题
          </a>
        
      </div>
    </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="1、谈谈你对-SPA-单页面模式的理解，优缺点-？"><a href="#1、谈谈你对-SPA-单页面模式的理解，优缺点-？" class="headerlink" title="1、谈谈你对 SPA 单页面模式的理解，优缺点 ？"></a>1、谈谈你对 SPA 单页面模式的理解，优缺点 ？</h2><p>SPA仅在web页面初始化时加载对应的HTML、JavaScript和CSS</p>
<ul>
<li>一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现HTML内容的变换，UI与用户的交互，避免页面的重新加载</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>用户体验好、快、，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>SPA对服务器压力小</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>初次加载耗时多：为实现单页Web应用功能及显示效果，需要在页面加载的时候将JavaScript、CSS统一加载，部分页面按需加载</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理</li>
<li>SEO难度大：由于所有内容都在一个页面中动态替换显示，所以SEO上其有着天然劣势</li>
</ul>
<h2 id="2、什么是MVVM"><a href="#2、什么是MVVM" class="headerlink" title="2、什么是MVVM"></a>2、什么是MVVM</h2><p><strong>什么是MVVM</strong></p>
<p>视图模型双向绑定，MVVM是Model-View-ViewModel的缩写，也就是把MVC中的Controller演变成ViewModel</p>
<p>Model层代表数据模型，view代表UI组件，ViewModel就是view和model的桥梁，数据会绑定到view Model层，并自动将数据渲染到视图中，视图变化时会通知viewModel层更新数据。以前是操作DOM结构更新视图，，现在是<code>数据驱动试图</code></p>
<p><strong>MVVM响应式原理</strong></p>
<p>vue是采用数据劫持配合发布者-订阅者的模式的方式，通过Object.defineProperty()来劫持各个属性的getter和setter，在数据变动时，发布消息给依赖收集器（dep中的subs），去通知（notify）观察者，做出对应的回调函数，去更新视图</p>
<p>MVVM作为绑定的入口，整合Observer,Compile和Watcher三者，通过Observer来监听model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer，Compile之间的通信桥路，达到数据变化&#x3D;&gt;视图更新；视图交互变化&#x3D;&gt;数据model变更的双向绑定效果。</p>
<p><strong>解决的问题：</strong></p>
<ul>
<li>开发者在代码中调用大量的DOM API，处理繁琐，操作冗余，使得代码难以维护</li>
<li>大量的DOM操作使页面渲染能力降低，加载速度变慢，影响用户体验</li>
<li>当Model频繁发生变化，开发者需要主动更新到View</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>低耦合。视图可以独立于模型变化和修改，一个模型可以绑定多个视图。当视图发生变化时模型可以不变化，当模型发生变化时视图也可以不变</li>
<li>可重用。可以把一些视图逻辑放到一个Model里</li>
<li>独立开发。开发人员可以把专注业务逻辑和数据的开发，设计人员可以专注于页面设计</li>
</ul>
<p><strong>和mvc的区别</strong> </p>
<p>Controller（控制器）是应用程序中处理用户交互的部分。一般包括业务处理模块和路由模块。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p>
<h2 id="3、谈谈双向绑定"><a href="#3、谈谈双向绑定" class="headerlink" title="3、谈谈双向绑定"></a>3、谈谈双向绑定</h2><p>采用数据劫持+发布订阅者模式，通过defineProperty来劫持各个属性的setter\getter,在数据变动时发布消息给订阅者，触发响应的监听回调</p>
<p><strong>Observer</strong>：数据监听器的核心是通过Object.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter，这时候Observer就要通知订阅者，订阅者就是Watcher</p>
<p><strong>Watcher</strong>:作为指令解析器和数据监听器之间的桥梁，主要做的：</p>
<ul>
<li>在自身实例化时，往属性订阅器里添加自己</li>
<li>自身必须有一个update方法</li>
<li>待属性变动dep.notice()通知时，能调用自身的update方法，并触发Compile中绑定的回调</li>
</ul>
<p><strong>Compile</strong>:指令解析器。主要解析模板指令，将模板变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加数据订阅者，一旦数据变动收到通知，更新视图。</p>
<h2 id="4、生命周期"><a href="#4、生命周期" class="headerlink" title="4、生命周期"></a>4、生命周期</h2><ul>
<li><p>单组件生命周期</p>
<ul>
<li>beforeCreate：VUE实例初始化后，组件创建、事件检测、watch&#x2F;event事件配置前调用</li>
<li>Created：组件创建后，data可访问，DOM未渲染。此时操作DOM应将DOM放在nextTick的回调中（nextTick会在下次DOM更新循环结束之后延迟回调</li>
<li>beforeMount：HTML编译完成，虚拟DOM已存在，但未渲染，可以发起服务器请求，$el可用，ref不可用</li>
<li>Mounted：$el已被vm.$el代替，ref可操作（在次进行异步请求发送操作）</li>
<li>beforeUpdate：适合更新前访问现有DOM，（手动移除事件监听器）</li>
<li>updated：数据更新后</li>
<li>beforeUnmount：</li>
<li>unmounted</li>
<li>errorCaptured</li>
<li>renderTracked</li>
<li>renderTriggered</li>
<li>activated</li>
<li>deactivated</li>
</ul>
</li>
<li><p>父子组件生命周期关系</p>
<ul>
<li>创建：父created–&gt;子created–&gt;子mounted–&gt;父mounted</li>
<li>更新：父beforeUpdate–&gt;子beforeUpdate–&gt;子updated–&gt;父updated</li>
<li>销毁：父beforeDestory–&gt;子beforeDestory–&gt;子destoryed–&gt;父destoryed</li>
</ul>
</li>
</ul>
<h2 id="5、Vue响应式数据原理"><a href="#5、Vue响应式数据原理" class="headerlink" title="5、Vue响应式数据原理"></a>5、Vue响应式数据原理</h2><p><strong>vue2.x</strong></p>
<ul>
<li>在初始化数据时，会使用Object.defineProperty重新定义data中所有属性</li>
<li>当页面使用对应属性时，首先会进行依赖收集，如果属性发生变化会通知相关依赖进行派发更新（发布订阅者模式）</li>
</ul>
<p>**vue3.x: **</p>
<ul>
<li>采用ES6中的proxy代替object.defineProerty做数据监听</li>
</ul>
<h2 id="6、Proxy与Object-defineProperty的优劣对比"><a href="#6、Proxy与Object-defineProperty的优劣对比" class="headerlink" title="6、Proxy与Object.defineProperty的优劣对比"></a>6、Proxy与Object.defineProperty的优劣对比</h2><p><strong>Proxy的优势：</strong></p>
<ul>
<li>Proxy可以直接监听对象而非属性</li>
<li>可以直接监听数组的变换</li>
<li>Proxy有13种拦截方法，不限于apply，ownKeys等等时object.defineProperty不具备的</li>
<li>Proxy返回的是一个对象，我们可以只操作新的对象达到目的，而object.defineProperty只能遍历对象属性直接修改</li>
<li>Proxy作为新标准将收到浏览器厂商重点持续的性能优化</li>
</ul>
<p><strong>defineProperty优势</strong></p>
<p>​	兼容性好</p>
<h2 id="7、v-show和v-if的区别"><a href="#7、v-show和v-if的区别" class="headerlink" title="7、v-show和v-if的区别"></a>7、v-show和v-if的区别</h2><ul>
<li>控制手段：v-show:display:none   v-if:不满足条件，直接删除节点</li>
<li>v-show：由false–&gt;true不会触发组件生命周期</li>
<li>v-if：false–&gt;true:触发beforeCreate,create,deforeMount,mounted<ul>
<li>true–&gt;false：beforeDestory,destory</li>
</ul>
</li>
<li>v-if:更高的切换消耗         v-for:更高的初始渲染消耗</li>
<li>v-if如果为true的话就会走正常流程创建AST语法树，如果为false就会创建空节点</li>
</ul>
<h2 id="8、v-if-和v-for为什么不建议一起用"><a href="#8、v-if-和v-for为什么不建议一起用" class="headerlink" title="8、v-if 和v-for为什么不建议一起用"></a>8、v-if 和v-for为什么不建议一起用</h2><p>v-for 和 v-if 不要在同一个标签中使用，因为解析时先解析 v-for 再解析 v-if（v-for 指令比 v-if 优先级高）。</p>
<h2 id="9、vue中data为什么必须是函数"><a href="#9、vue中data为什么必须是函数" class="headerlink" title="9、vue中data为什么必须是函数"></a>9、vue中data为什么必须是函数</h2><p>一个组件被复用多次会创建多个实例，这些实例用的同一个构造函数。data如果是对象，属于引用类型，一改其他也改。</p>
<h2 id="10、nextTick"><a href="#10、nextTick" class="headerlink" title="10、nextTick"></a>10、nextTick</h2><p>vue实现响应式并不是在数据改变后立即更新DOM，使用vm.$nextTick是在下次DOM更新循环结束后立即执行延迟回调</p>
<ul>
<li>想要在Vue生命周期函数中的<code>created()</code>操作DOM可以使用<code>Vue.nextTick()</code>回调函数</li>
<li>在数据改变后要执行的操作，而这个操作需要等数据改变后而改变DOM结构的时候才进行操作，需要用到<code>nextTick</code></li>
<li><code>nextTick</code>的内部实现如果支持 <code>promise</code> 那就使用 <code>promise</code>，没有就用<code>MutationObserver</code>（微任务），在没有就用 <code>setImmediate</code>（宏任务），还没有就用 <code>setTimeOut</code>；<strong>所以<code>nextTick</code> 有可能是宏任务，也有可能是微任务</strong></li>
</ul>
<h2 id="11、key"><a href="#11、key" class="headerlink" title="11、key"></a>11、key</h2><ul>
<li>key是v-for渲染列表时的节点标识。使用了key之后，当列表项发生变化时，vue会基于key的变化而重新排列元素顺序，并移除key不存在元素，而不是一个销毁重新生成的过程，提升运行效率。</li>
<li>key主要用在虚拟Dom算法中，每个虚拟节点VNode有一个唯一标识Key，通过对比新旧节点的key来判断节点是否改变，用key就可以大大提高渲染效率，这个key类似于缓存中的etag。</li>
</ul>
<p><strong>虚拟DOM</strong></p>
<ul>
<li>缺点<ul>
<li>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢</li>
</ul>
</li>
<li>优点<ul>
<li>减少了dom操作，减少了回流与重绘</li>
<li>保证性能的下限，虽说性能不是最佳，但是它具备局部更新的能力，所以大部分时候还是比正常的DOM性能高很多的</li>
</ul>
</li>
</ul>
<h2 id="12、v-model-双向数据绑定原理"><a href="#12、v-model-双向数据绑定原理" class="headerlink" title="12、v-model 双向数据绑定原理"></a>12、v-model 双向数据绑定原理</h2><p>vue 双向数据绑定是通过 <strong>数据劫持</strong> 结合 <strong>发布订阅模式</strong> 的方式来实现的，也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变； 核心：<code>Object.defineProperty()</code>方法。</p>
<p><code>v-model</code>本质上是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件</li>
</ul>
<h2 id="13、router和route的区别"><a href="#13、router和route的区别" class="headerlink" title="13、router和route的区别"></a>13、router和route的区别</h2><ul>
<li>$route 是<strong>路由信息对象</strong>，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。</li>
<li>而$router 是<strong>路由实例对象</strong>，包括了路由的跳转方法，钩子函数等。</li>
</ul>
<h2 id="14、Vuex-页面刷新数据丢失怎么解决-？"><a href="#14、Vuex-页面刷新数据丢失怎么解决-？" class="headerlink" title="14、Vuex 页面刷新数据丢失怎么解决 ？"></a>14、Vuex 页面刷新数据丢失怎么解决 ？</h2><ul>
<li><strong>需要做 vuex 数据持久化</strong> 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件</li>
<li><strong>推荐使用 vuex-persist 插件</strong>，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中</li>
</ul>
<h2 id="15、你都做过哪些-Vue-的性能优化，还有有哪些可以做-？"><a href="#15、你都做过哪些-Vue-的性能优化，还有有哪些可以做-？" class="headerlink" title="15、你都做过哪些 Vue 的性能优化，还有有哪些可以做 ？"></a>15、你都做过哪些 Vue 的性能优化，还有有哪些可以做 ？</h2><p><strong>1）编码阶段</strong></p>
<ul>
<li>不要在模板里面写过多表达式</li>
<li>尽量减少 data 中的数据，data 中的数据都会增加<code>getter</code> 和 <code>setter</code>，会收集对应的<code>watcher</code></li>
<li>不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）</li>
<li>对象层级不要过深，否则性能就会差</li>
<li>computed 和 watch 区分使用场景</li>
<li>v-if 和 v-for 不能连用</li>
<li>如果需要使用 v-for 给每项元素绑定事件时使用事件代理</li>
<li>SPA 页面采用 <code>keep-alive</code> 缓存组件</li>
<li>频繁切换的使用 v-show，不频繁切换的使用 v-if</li>
<li>v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if</li>
<li>使用路由懒加载、异步组件</li>
<li>防抖、节流运用</li>
<li>第三方模块按需导入</li>
<li>大数据列表和表格性能优化 - 虚拟列表&#x2F;虚拟表格</li>
<li>图片懒加载</li>
</ul>
<p><strong>（2）搜索引擎 SEO 优化</strong></p>
<ul>
<li>预渲染</li>
<li>服务端渲染 SSR，nuxt.js</li>
</ul>
<p><strong>（3）打包优化</strong></p>
<ul>
<li>压缩代码</li>
<li>Tree Shaking &#x2F; Scope Hoisting</li>
<li>使用 CDN 加载第三方模块</li>
<li>多线程打包 happypack</li>
<li>splitChunks 抽离公共文件</li>
<li>sourceMap 优化</li>
</ul>
<p><strong>（4）用户体验</strong></p>
<ul>
<li>骨架屏</li>
<li>PWA 渐进式 Web 应用，使用多种技术来增强 web app 的功能，让网页应用呈现和原生应用相似的体验。</li>
</ul>
<h2 id="16、Vue有了数据响应式，为何还要Diff"><a href="#16、Vue有了数据响应式，为何还要Diff" class="headerlink" title="16、Vue有了数据响应式，为何还要Diff"></a>16、Vue有了数据响应式，为何还要Diff</h2><p><strong>核心原因：粒度</strong></p>
<ul>
<li>Vue 可以通过响应式系统知道哪里发生了变化，但是所有变化都通过响应式会创建大量 Watcher，极其消耗性能，因此 vue 采用的方式是通过响应式系统知道哪个组件发生了变化，然后在组件内部使用 diff。</li>
<li>这样的<strong>中粒度策略</strong>，即不会产生大量的 Watcher，也使 diff 的节点减少了，一举两得。</li>
</ul>
<h2 id="17、vue如何监听数组"><a href="#17、vue如何监听数组" class="headerlink" title="17、vue如何监听数组"></a>17、vue如何监听数组</h2><p>object.defineProperty限制，VUE无法监听到对象或数组内部某个属性值的变化，因此直接设置以上两类数据时，页面不会实时更新。解决方法：</p>
<ul>
<li>this.$set(要改的对象&#x2F;数组, key, 改成的值)</li>
<li>this.$forceUpdate()<pre class="highlight"><span class="line"><span class="attr">change</span>: <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">list</span>[index].<span class="property">sex</span> = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.$forceUpdate();</span><br><span class="line">&#125;</span><br></pre></li>
</ul>
<p>数组原生方法造成的数据更新可以被监听（pop,push,splice…)</p>
<h2 id="18、为什么vue要采用异步更新"><a href="#18、为什么vue要采用异步更新" class="headerlink" title="18、为什么vue要采用异步更新"></a>18、为什么vue要采用异步更新</h2><p>因为首先 Vue 本身是组件级更新的，更改数据如果非常多，更新非常频繁，如果不采用异步更新的话每次都需要重新渲染。</p>
<p>每次有数据需要更新的时候，Vue 会把它放在一个队列中，等最后的时候会调用 nexttick 方法。nexttick就会清空这个队列。</p>
<p>用户也可以手动调用 nexttick(callback) 方法，会同样把callback 回调函数放入队列中，保证视图更新完之后被调用（因为会把 callback 放进队列的最后），并且是依次链式调用。</p>
<h2 id="19、computed、watch、method的区别"><a href="#19、computed、watch、method的区别" class="headerlink" title="19、computed、watch、method的区别"></a>19、computed、watch、method的区别</h2><p><strong>computed</strong>:支持缓存，只有依赖数据变化时，才会重新计算函数，计算属性内部不支持异步</p>
<p><strong>watch</strong>:不支持缓存，只要数据变就会执行侦听函数。内部支持异步操作。侦听函数值可以是一个对象（handler:回调  deep:监听内部值   immediate:立即回调）</p>
<p><strong>method</strong>: 使用：<code> &#123;&#123;fn(x)&#125;&#125;</code>,渲染的时候如果没有发生变化，这个也是会被执行的。而<code>computed</code>是有缓存的，如果没有变化就不用再去执行了。</p>
<p><strong>使用场景</strong>：</p>
<p>一个属性受多个属性影响用computed；一个数据影响多条数据用watch</p>
<h2 id="20、vue-router的模式"><a href="#20、vue-router的模式" class="headerlink" title="20、vue-router的模式"></a>20、vue-router的模式</h2><p><strong>hash模式</strong>：在路径后面加“#”，后面的hash值发生变化，浏览器既不向服务器发请求，也不刷新。每次hash值变，会触发hashchange事件</p>
<p><strong>history</strong>:用html5中的pushState()和replaceState()方法将URL替换但不刷新。提供浏览器对历史纪录进行修改的功能。只是当他们修改时，虽然改变了当前URL但不会立即向后端发请求。不过在部署的时候需要服务器处理，例如 nginx 跳转处理，防止 404 问题。</p>
<h2 id="21、组件间的通信方式"><a href="#21、组件间的通信方式" class="headerlink" title="21、组件间的通信方式"></a>21、组件间的通信方式</h2><ul>
<li><p>父传子：父v-bind    子：props</p>
</li>
<li><p>子传父：子： $emit         父v-on</p>
</li>
<li><p>任意组件通信，新建一个空的全局Vue对象，利用 emit发送，on接收</p>
<pre class="highlight"><span class="line">Vue.prototype.Event=new Vue();</span><br><span class="line">  	</span><br><span class="line">  </span><br><span class="line">Event.$emit(事件名,数据);</span><br><span class="line">Event.$on(事件名,data =&gt; &#123;&#125;);</span><br><span class="line">  </span><br></pre>
</li>
<li><p>vueX</p>
<blockquote>
<p>状态管理模式。每一个Vuex应用的核心就是store.”store”是一个容器，包含应用中的大部分状态</p>
</blockquote>
<ul>
<li>state：定义了应用状态的数据结构，可以在这里设置默认的初始状态</li>
<li>getters：允许组件从Store中获取数据</li>
<li>mutations：唯一更改store中状态的方法<br>this.$store.commit(“方法名”,数据)<br>也可使用mapMutations ，使用方法和以上一样</li>
<li>actions：提交mutation，而不是直接变更状态，可以包含任意异步操作</li>
<li>modules：允许将单一的store拆分成多个store且同时保存在单一的状态树中</li>
</ul>
</li>
</ul>
<h2 id="22、vue-router有哪几种钩子函数-导航守卫有多少种"><a href="#22、vue-router有哪几种钩子函数-导航守卫有多少种" class="headerlink" title="22、vue-router有哪几种钩子函数(导航守卫有多少种)"></a>22、vue-router有哪几种钩子函数(导航守卫有多少种)</h2><p>vue-router 导航守卫有三种，分别是：全局守卫，路由独享守卫，组件内守卫<br>全局守卫又分三种：分别是全局前置，全局解析，全局后置。</p>
<ul>
<li>beforeEach（全局前置）<ul>
<li>一般可以用来做权限控制，不符合的话直接返回登录页面。</li>
<li>参数有<ul>
<li>to(Route路由对象)</li>
<li>from(Route路由对象)</li>
<li>next(function函数) 一定要调用才能进行下一步</li>
</ul>
</li>
</ul>
</li>
<li>router.beforeResolve（全局解析守卫），在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</li>
<li>afterEach（全局后置）：不会接受 next 函数也不会改变导航本身。<br>组件内守卫允许在组件内部做处理，有三个钩子，分别是 beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave。</li>
<li>beforeRouterLeave可以在路由离开前做以下二次确认</li>
</ul>
<h2 id="vue-Router路由钩子解析流程"><a href="#vue-Router路由钩子解析流程" class="headerlink" title="vue-Router路由钩子解析流程"></a>vue-Router路由钩子解析流程</h2><p>导航被触发。<br>在失活的组件里调用 beforeRouteLeave 守卫。<br>调用全局的 beforeEach 守卫。<br>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。<br>在路由配置里调用 beforeEnter。<br>解析异步路由组件。<br>在被激活的组件里调用 beforeRouteEnter。<br>调用全局的 beforeResolve 守卫 (2.5+)。<br>导航被确认。<br>调用全局的 afterEach 钩子。<br>触发 DOM 更新。<br>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</p>
<h2 id="23、事件修饰符"><a href="#23、事件修饰符" class="headerlink" title="23、事件修饰符"></a>23、事件修饰符</h2><p>@click.sync 语法</p>
<p><comp :foo.sync="bar"></comp> 相当于 &lt;comp :foo&#x3D;”bar” @update:foo&#x3D;”val &#x3D;&gt; bar &#x3D; val”&gt;</comp><br>@click.native 父组件的原生事件需要加上 native，否则不生效</p>
<p>@click.stop 是阻止冒泡</p>
<p>@click.prevent 是阻止默认行为</p>
<p>@click.self 点击自己的时候才能触发</p>
<h2 id="24、v-html会导致什么问题"><a href="#24、v-html会导致什么问题" class="headerlink" title="24、v-html会导致什么问题"></a>24、v-html会导致什么问题</h2><p>可能会造成xss攻击</p>
<h2 id="25、怎么缓存组件"><a href="#25、怎么缓存组件" class="headerlink" title="25、怎么缓存组件"></a>25、怎么缓存组件</h2><p>keep-alive是vue中的内置组件，不会被渲染到真实DOM中，也不会出现在父组件链中。能在组件切换过程中将状态保留在内存里，防止重复渲染DOM。</p>
<p>keep可以设置include:只有名称匹配的组件会被缓存；exclude：名称匹配的不被缓存；max:最多缓存多少组实例</p>
<p>设置keep-alive的会多出两个生命周期钩子：activated&#x2F;deactived</p>
<p><strong>keep-alive原理</strong>：</p>
<p>vue.js内部将DOM节点抽象成一个个vnode节点，keep-alive组件的缓存也是基于Vnode节点的，而不是直接存储DOM结构。它将满足条件的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache中取出</p>
<p><strong>首次进入时：</strong>beforeRouterEnter–&gt;beforeCreated–&gt;created–&gt;beforeMounte–&gt;Mounted–&gt;activated–&gt; …–&gt;beforeRouterLeave–&gt;deactived</p>
<p><strong>再次进入时：</strong>beforeRouterEnter –&gt; activated–&gt;beforeRouterLeave–&gt;deactived</p>
<p><strong>缓存后如何获取数据</strong></p>
<pre class="highlight"><span class="line"><span class="comment">//1\</span></span><br><span class="line"><span class="title function_">beforeRouterEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)&#123;</span><br><span class="line">    <span class="title function_">next</span>( <span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">        vm.<span class="title function_">getData</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="title function_">activated</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getData</span>()</span><br><span class="line">&#125;</span><br></pre>

<h2 id="26、什么是render函数"><a href="#26、什么是render函数" class="headerlink" title="26、什么是render函数"></a>26、什么是render函数</h2><p>模板编译的过程：</p>
<ul>
<li>提取出模板中的原生 HTML 和非原生 HTML，比如绑定的属性、事件、指令等等</li>
<li>经过一些处理生成 render 函数</li>
<li>render 函数再将模板内容生成对应的 vnode<br>render是一个函数，有一个ceateElement形参，这个形参也作为一个方法（可以动态创建标签），可传入三个参数：标签名、属性内容<br><a target="_blank" rel="noopener" href="https://fe.ecool.fun/topic/418ef81f-96c6-4c4e-b218-df29be84890d?orderBy=updateTime&amp;order=desc&amp;tagId=14">https://fe.ecool.fun/topic/418ef81f-96c6-4c4e-b218-df29be84890d?orderBy=updateTime&amp;order=desc&amp;tagId=14</a></li>
</ul>
<h2 id="27、documentFragment和一次性渲染有什么不同"><a href="#27、documentFragment和一次性渲染有什么不同" class="headerlink" title="27、documentFragment和一次性渲染有什么不同"></a>27、documentFragment和一次性渲染有什么不同</h2><ul>
<li>documentFrament 首先是虚拟的，它的节点增加与删除肯定不会引起 dom 的变化的，所以如果增加节点或者删除节点使用 createDocumentFrament 的话会减少回流的操作。</li>
<li>Vue 也是使用了 CreateDocumentFragment 的。如果初次渲染，使用 documentFragment会多一个步骤，也就是创建这个documentFragment的步骤，所以一般首次加载是很慢的。</li>
</ul>
<h2 id="28、自定义指令"><a href="#28、自定义指令" class="headerlink" title="28、自定义指令"></a>28、自定义指令</h2><p>全局注册：Vue.directive(指令名， 指令函数)，这时的指令名不加v，用的时候再加</p>
<p>局部注册：options中设置directive</p>
<h2 id="29、Vue获取DOM元素"><a href="#29、Vue获取DOM元素" class="headerlink" title="29、Vue获取DOM元素"></a>29、Vue获取DOM元素</h2><p>将要获取元素标签上设置ref属性，通过<code>this.$refs.属性值</code>获取</p>
<h2 id="30、初始化页面闪动问题"><a href="#30、初始化页面闪动问题" class="headerlink" title="30、初始化页面闪动问题"></a>30、初始化页面闪动问题</h2><p><strong>原因</strong>：vue代码尚未解析之前，无法控制DOM显示</p>
<p><strong>解决</strong>：在css中加<code>[v-clock] &#123;diaplay: none&#125;</code>, 在待编译标签上加v-clock属性</p>
<h2 id="31、数组扁平化"><a href="#31、数组扁平化" class="headerlink" title="31、数组扁平化"></a>31、数组扁平化</h2><pre class="highlight"><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     children:[</span></span><br><span class="line"><span class="comment">//         &#123;value: 1&#125;,</span></span><br><span class="line"><span class="comment">//         &#123;value: 2&#125;,</span></span><br><span class="line"><span class="comment">//         &#123;value: 3&#125;,&#123;</span></span><br><span class="line"><span class="comment">//             children:[</span></span><br><span class="line"><span class="comment">//                 &#123;value: 4&#125;,</span></span><br><span class="line"><span class="comment">//                 &#123;value: 5&#125;</span></span><br><span class="line"><span class="comment">//             ]</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     ]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="comment">// 如果遍历到的数字是number，直接放入</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> arr[i] == <span class="string">&#x27;number&#x27;</span>)&#123;</span><br><span class="line">            result.<span class="title function_">push</span>(&#123;</span><br><span class="line">                <span class="attr">value</span>: arr[i]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i]))&#123;</span><br><span class="line">            <span class="comment">//如果是数组就递归</span></span><br><span class="line">            result.<span class="title function_">push</span>(&#123;</span><br><span class="line">                <span class="attr">children</span>: <span class="title function_">convert</span>(arr[i])</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre>

<h2 id="32-emit后面的两个参数是什么"><a href="#32-emit后面的两个参数是什么" class="headerlink" title="32.$emit后面的两个参数是什么"></a>32.$emit后面的两个参数是什么</h2><p><code>vm.$emit( event, args)</code>触发当前实例上的事件，要传递的参数</p>
<p><code>vm.$on(event, fn)</code>监听event事件后运行fn</p>
<h2 id="33-插槽"><a href="#33-插槽" class="headerlink" title="33.插槽"></a>33.插槽</h2><p>vue组件中的占位符，可以让用户更好的复用组件<br>如果组件的template中没有包含一个<code>&lt;slot&gt;</code>元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃</p>
<blockquote>
<p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。因此插槽不能访问<slot>标签所在的组件的数据</p>
</blockquote>
<ul>
<li>匿名插槽</li>
<li>具名插槽<br><code>&lt;slot name=&quot;名字&quot;&gt;&lt;/slot&gt;</code>，能够控制多个插槽渲染到具体位置</li>
<li>作用域插槽<br>父组件提供的插槽内容上可以用子组件中的数据：<pre class="highlight"><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;( item, index ) in items&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:item</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></li>
</ul>
<h2 id="34、mixin"><a href="#34、mixin" class="headerlink" title="34、mixin"></a>34、mixin</h2><p>mixin用于抽离多个组件间重复的逻辑</p>
<p><strong>场景</strong>：PC端新闻列表和详情页一样的右侧栏目，可以使用mixin进行混合</p>
<p><strong>劣势</strong>：1、变量来源不明确，不利于阅读。2、多mixin可能会造成命名冲突。3、mixin和组件可能出现多对多的关系，使得项目复杂度变高。</p>
<p>vue3中的Composition API可以解决</p>
<h2 id="35、描述vue从初始化页面–修改数据–刷新页面UI的过程"><a href="#35、描述vue从初始化页面–修改数据–刷新页面UI的过程" class="headerlink" title="35、描述vue从初始化页面–修改数据–刷新页面UI的过程"></a>35、描述vue从初始化页面–修改数据–刷新页面UI的过程</h2><p>当vue进入初始化阶段时，一方面vue会遍历data中的属性，并用Object.defineProperty()将它转化为getter&#x2F;setter的形式，实现数据劫持；另一方面，vue指令编译器对元素节点的各个指令进行解析，初始化视图，并订阅watcher来更新视图，此时watcher会将自己添加到消息订阅器中，此时初始化完毕。</p>
<p>当数据发生变化时，触发Observer中的setter，立即调用Dep.notify().Dep这个数组开始遍历所有的订阅者，并调用其update方法，vue内部再通过diff算法，patch相应的更新，完成对订阅者视图的改变。</p>
<h2 id="36、class-与-style-如何动态绑定？"><a href="#36、class-与-style-如何动态绑定？" class="headerlink" title="36、class 与 style 如何动态绑定？"></a>36、class 与 style 如何动态绑定？</h2><p>class 一般通过对象或者数组来实现</p>
<ul>
<li><p>当使用对象时，当 [value] 为 true 的时候使用 [key]，语法如下<br><code>v-bind:className=&quot;&#123; active: isActive, error: isError &#125;&quot;</code><br> 当 isActive &#x3D; true; isError &#x3D; false; 时 class 值为 active</p>
</li>
<li><p>当使用数组时，使用三目运算符号来控制，语法如下<br><code>v-bind:className=&quot;[isActive ? active : &#39;&#39;, error]&quot;</code><br>当 <code>isActive = true; isError = false;</code> 时 class 值为 active</p>
</li>
</ul>
<p>同理 style 属性也可以通过对象或者数组来实现</p>
<h2 id="37、vue中的diff算法"><a href="#37、vue中的diff算法" class="headerlink" title="37、vue中的diff算法"></a>37、vue中的diff算法</h2><ul>
<li>当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁</li>
<li>通过isSameVnode进行判断，相同则调用patchVnode方法</li>
<li>patchVnode做了以下操作：<ul>
<li>找到对应的真实dom，称为el</li>
<li>如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点</li>
<li>如果oldVnode有子节点而VNode没有，则删除el子节点</li>
<li>如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el</li>
<li>如果两者都有子节点，则执行updateChildren函数比较子节点</li>
</ul>
</li>
<li>updateChildren主要做了以下操作：<ul>
<li>设置新旧VNode的头尾指针</li>
<li>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作</li>
</ul>
</li>
</ul>

  </div>
  <div>
    
      <div 
        class="post-note note-warning copyright" 
        style="margin-top: 42px">
        <p>
          <span style="font-weight: bold;">作者：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="/about">
            Nana
          </a>
        </p>
        <p>
          <span style="font-weight: bold;">文章链接：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="http://example.com/2022/07/10/Vue/">
            http://example.com/2022/07/10/Vue/
          </a>
        </p>
        <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
      </div>
    
  </div>
</article>
<div class="nav">
  
    <div class="nav-item-prev">
      <a 
        href="/2022/07/11/Git/" 
        class="nav-link">
        <i class="iconfont icon-left nav-prev-icon"></i>
        <div>
          <div class="nav-label">Prev</div>
          
            <div class="nav-title">Git </div>
          
        </div>
      </a>
    </div>
  
  
    <div class="nav-item-next">
      <a 
        href="/2022/07/09/MarkDown/" 
        class="nav-link">
        <div>
          <div class="nav-label">Next</div>
          
            <div class="nav-title">MarkDown </div>
          
        </div>
        <i class="iconfont icon-right nav-next-icon"></i>
      </a>
    </div>
  
</div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9-%EF%BC%9F"><span class="toc-text">1、谈谈你对 SPA 单页面模式的理解，优缺点 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMVVM"><span class="toc-text">2、什么是MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%B0%88%E8%B0%88%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-text">3、谈谈双向绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4、生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86"><span class="toc-text">5、Vue响应式数据原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Proxy%E4%B8%8EObject-defineProperty%E7%9A%84%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="toc-text">6、Proxy与Object.defineProperty的优劣对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81v-show%E5%92%8Cv-if%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7、v-show和v-if的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81v-if-%E5%92%8Cv-for%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%B8%80%E8%B5%B7%E7%94%A8"><span class="toc-text">8、v-if 和v-for为什么不建议一起用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81vue%E4%B8%ADdata%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-text">9、vue中data为什么必须是函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81nextTick"><span class="toc-text">10、nextTick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81key"><span class="toc-text">11、key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81v-model-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-text">12、v-model 双向数据绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81router%E5%92%8Croute%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13、router和route的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81Vuex-%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-%EF%BC%9F"><span class="toc-text">14、Vuex 页面刷新数据丢失怎么解决 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E4%BD%A0%E9%83%BD%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B-Vue-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%E8%BF%98%E6%9C%89%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E5%81%9A-%EF%BC%9F"><span class="toc-text">15、你都做过哪些 Vue 的性能优化，还有有哪些可以做 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81Vue%E6%9C%89%E4%BA%86%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%8C%E4%B8%BA%E4%BD%95%E8%BF%98%E8%A6%81Diff"><span class="toc-text">16、Vue有了数据响应式，为何还要Diff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84"><span class="toc-text">17、vue如何监听数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88vue%E8%A6%81%E9%87%87%E7%94%A8%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0"><span class="toc-text">18、为什么vue要采用异步更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81computed%E3%80%81watch%E3%80%81method%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">19、computed、watch、method的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81vue-router%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-text">20、vue-router的模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">21、组件间的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81vue-router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D"><span class="toc-text">22、vue-router有哪几种钩子函数(导航守卫有多少种)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-Router%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-text">vue-Router路由钩子解析流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">23、事件修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81v-html%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">24、v-html会导致什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E6%80%8E%E4%B9%88%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6"><span class="toc-text">25、怎么缓存组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFrender%E5%87%BD%E6%95%B0"><span class="toc-text">26、什么是render函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81documentFragment%E5%92%8C%E4%B8%80%E6%AC%A1%E6%80%A7%E6%B8%B2%E6%9F%93%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-text">27、documentFragment和一次性渲染有什么不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">28、自定义指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81Vue%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0"><span class="toc-text">29、Vue获取DOM元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E9%97%AA%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-text">30、初始化页面闪动问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-text">31、数组扁平化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-emit%E5%90%8E%E9%9D%A2%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">32.$emit后面的两个参数是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%8F%92%E6%A7%BD"><span class="toc-text">33.插槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81mixin"><span class="toc-text">34、mixin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E6%8F%8F%E8%BF%B0vue%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E2%80%93%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E2%80%93%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2UI%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">35、描述vue从初始化页面–修改数据–刷新页面UI的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81class-%E4%B8%8E-style-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%9F"><span class="toc-text">36、class 与 style 如何动态绑定？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95"><span class="toc-text">37、vue中的diff算法</span></a></li></ol></li></ol>
</div>
            </main>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9-%EF%BC%9F"><span class="toc-text">1、谈谈你对 SPA 单页面模式的理解，优缺点 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMVVM"><span class="toc-text">2、什么是MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%B0%88%E8%B0%88%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-text">3、谈谈双向绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4、生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86"><span class="toc-text">5、Vue响应式数据原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Proxy%E4%B8%8EObject-defineProperty%E7%9A%84%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="toc-text">6、Proxy与Object.defineProperty的优劣对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81v-show%E5%92%8Cv-if%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7、v-show和v-if的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81v-if-%E5%92%8Cv-for%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%B8%80%E8%B5%B7%E7%94%A8"><span class="toc-text">8、v-if 和v-for为什么不建议一起用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81vue%E4%B8%ADdata%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-text">9、vue中data为什么必须是函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81nextTick"><span class="toc-text">10、nextTick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81key"><span class="toc-text">11、key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81v-model-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-text">12、v-model 双向数据绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81router%E5%92%8Croute%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13、router和route的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81Vuex-%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-%EF%BC%9F"><span class="toc-text">14、Vuex 页面刷新数据丢失怎么解决 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E4%BD%A0%E9%83%BD%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B-Vue-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%E8%BF%98%E6%9C%89%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E5%81%9A-%EF%BC%9F"><span class="toc-text">15、你都做过哪些 Vue 的性能优化，还有有哪些可以做 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81Vue%E6%9C%89%E4%BA%86%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%8C%E4%B8%BA%E4%BD%95%E8%BF%98%E8%A6%81Diff"><span class="toc-text">16、Vue有了数据响应式，为何还要Diff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84"><span class="toc-text">17、vue如何监听数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88vue%E8%A6%81%E9%87%87%E7%94%A8%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0"><span class="toc-text">18、为什么vue要采用异步更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81computed%E3%80%81watch%E3%80%81method%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">19、computed、watch、method的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81vue-router%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-text">20、vue-router的模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">21、组件间的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81vue-router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D"><span class="toc-text">22、vue-router有哪几种钩子函数(导航守卫有多少种)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-Router%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-text">vue-Router路由钩子解析流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">23、事件修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81v-html%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">24、v-html会导致什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E6%80%8E%E4%B9%88%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6"><span class="toc-text">25、怎么缓存组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFrender%E5%87%BD%E6%95%B0"><span class="toc-text">26、什么是render函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81documentFragment%E5%92%8C%E4%B8%80%E6%AC%A1%E6%80%A7%E6%B8%B2%E6%9F%93%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-text">27、documentFragment和一次性渲染有什么不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">28、自定义指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81Vue%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0"><span class="toc-text">29、Vue获取DOM元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E9%97%AA%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-text">30、初始化页面闪动问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-text">31、数组扁平化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-emit%E5%90%8E%E9%9D%A2%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">32.$emit后面的两个参数是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%8F%92%E6%A7%BD"><span class="toc-text">33.插槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81mixin"><span class="toc-text">34、mixin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E6%8F%8F%E8%BF%B0vue%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E2%80%93%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E2%80%93%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2UI%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">35、描述vue从初始化页面–修改数据–刷新页面UI的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81class-%E4%B8%8E-style-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%9F"><span class="toc-text">36、class 与 style 如何动态绑定？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95"><span class="toc-text">37、vue中的diff算法</span></a></li></ol></li></ol>
    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>Recent Posts
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-08-08</div>
        <a href="/2022/08/08/%E6%B5%8F%E8%A7%88%E5%99%A8/"><div class="recent-posts-item-content">浏览器</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-08-08</div>
        <a href="/2022/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><div class="recent-posts-item-content">计算机网络</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-07-11</div>
        <a href="/2022/07/11/Git/"><div class="recent-posts-item-content">Git</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-07-10</div>
        <a href="/2022/07/10/Vue/"><div class="recent-posts-item-content">Vue</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2020
          
          
                - 
                2022
          
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          Phil
        </a>
      </div>
    </div>

    
      <div class="footer-dsc">
        
          Powered by
          <a 
            href="https://hexo.io/" 
            class="footer-link" 
            target="_blank" 
            rel="nofollow noopener noreferrer">
            &nbsp;Hexo
          </a>
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          Theme -
          <a 
            href="https://github.com/theme-kaze" 
            class="footer-link" 
            target="_blank"
            rel="nofollow noopener noreferrer">
            &nbsp;Kaze
          </a>
        
      </div>
    
    
    
    
</footer>
 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton"
  aria-label="menu button"
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
    
    <script src="//instant.page/5.1.0" type="module"
      integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
    
    
  </body>
</html>
